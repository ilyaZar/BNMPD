#' Generate config file \code{setup_inits.json} from simulated data
#'
#' Parses parameter object used to generate simulated data (generated by
#' [new_trueParams()]).
#'
#' @param params_used an object of \code{class} true_params (i.e. constructed
#'   via [new_trueParams()]) e.g. 'zeroParams' 'usedParams', see
#'   [get_zero_or_defaults()] and [generate_simulation_study()]
#' @inheritParams generate_yaml_model_defintion
#'
#' @return pure side-effect function that generates the \code{json}-file
#' @export
generate_setup_init_json <- function(params_used, pth_project) {
  if (is.null(params_used)) {
    cat(crayon::blue("No first argument 'params_used': no json-file generated"))
    return(invisible(params_used))
  }
  pth_to_json <- file.path(pth_project, "model",
                           "model-definition",
                           "setup_inits.json")

  DD <- get_dimension(params_used, dim = "DD")
  dist <- get_distribution(params_used)
  if (dist %in% c("gen_dirichlet", "gen_dirichlet_mult")) {
    DD1         <- get_DD1(dist, DD)
    list_json   <- list()

    list_json_A <- get_list_json_default(params_used, type = "A", DD1)
    list_json_B <- get_list_json_default(params_used, type = "B", DD1)

    for (d in 1:DD1) {
      tmp_dd_name <- name_json_dd_elem(type = NULL, d)
      list_json[[tmp_dd_name]] <- c(list_json_A[d], list_json_B[d])
    }
  } else {
    list_json <- get_list_json_default(params_used, type = NULL, DD)
  }
  jsonlite::write_json(list_json, pth_to_json, digits = 8, pretty = TRUE)
  return(invisible(params_used))
}
get_list_json_default <- function(params_used, type, DD) {
  list_json <- list()
  for(d in seq_len(DD)) {
    name_list_elem <- name_json_dd_elem(type, d)
    par_avail <- get_par_avail(params_used, type = type, num_d = d)
    par_to_list <- list()
    for (j in names(par_avail)) {
      par_to_list[[j]] <- par_to_list(par_avail[[j]], j, d)
    }
    list_json[[name_list_elem]] <- par_to_list
  }
  return(list_json)
}
name_json_dd_elem <- function(type, d) {
  if (!is.null(type)) type <- paste0(type, "_")
  paste0("D", type, ifelse(d < 10, paste0(0, d), d))
}
par_to_list <- function(par_val, par_name, num_d) {
  if (par_name == "phi") {
    num_comp <- seq_len(length(par_val))
    lab <- paste0("phi_{", num_comp, ",", num_d,"}")
    var <- paste0(par_name, "_", num_comp, "_", num_d)
    val <- par_val
  }
  if (par_name == "beta_z_lin") {
    num_comp <- seq_along(par_val)
    lab <- paste0("beta_{z", num_comp, ",", num_d, "}^{lin}")
    var <- paste0("Z_", num_comp, "_", num_d)
    val <- par_val
  }
  if (par_name == "beta_u_lin") {
    if (is.null(nrow(par_val))) {
      num_comp <- 1
    } else {
      num_comp <- seq_len(nrow(par_val))
    }
    lab <- paste0("beta_{u", num_comp, ",", num_d, "}^{lin}")
    var <- paste0("U_", num_comp, "_", num_d)
    val <- par_val
  }
  if (par_name == "vcm_u_lin") {
    lab <- paste0("vcm_beta_u{", num_d,"}")
    var <- paste0("buVCM", num_d)
    val <- par_val
  }
  if (par_name == "sig_sq") {
    lab <- paste0("sigma_{", num_d,"}")
    var <- paste0(par_name, num_d)
    val <- par_val
  }
  list(lab =  lab,
       var =  var,
       val =  val)
}
get_par_avail <- function(params_used, type = NULL, num_d) {
  check_pars <- c("phi", "beta_z_lin", "beta_u_lin", "sig_sq", "vcm_u_lin")
  id_avail  <- NULL
  par_avail <- vector("list", length(check_pars))
  names(par_avail) <- check_pars
  jj <- 1
  for (par_tmp in check_pars) {
    if(check_avail_param(params_used, par_tmp)) {
      if (par_tmp %in% c("phi", "sig_sq")) {tmp_n <- 1} else {tmp_n <- NULL}
      par_avail[[jj]] <- get_params(
                           params_used,
                           n = tmp_n,
                           DD = num_d,
                           name_par = par_tmp,
                           DD_TYPE = type)
      id_avail <- c(id_avail, jj)
    }
    jj <- jj + 1
  }
  par_avail[id_avail]
}
