# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' State transition
#'
#' Helper function computing the deterministic state transition, or, to put
#' differently, the one-period ahead conditional mean of the latent state
#' process. This version is required for the MCMC part, not the SMC part.
#'
#' This function is used internally in the PGAS procedure for MCMC sampling of
#' parameters when subtracting the mean from the state process: it is applied
#' per state component \code{d=1,...,DD} on a \code{TTx1}-dimensional state
#' vector where \code{TT} is the number of time periods of all the \code{DD}
#' components. This is the reason for \code{regs_add} to be a vector as it adds
#' regressor*beta (i.e. regressors matrix time coefficient vector) change for
#' all \code{t=1,...,T}.
#'
#' @param x_tt particle value in t-1 i.e. x_{t-1}; \code{TTx1}-dimensional
#'   vector (double)
#' @param phi_x autoregressive parameter (double)
#' @param regs_add result of regressor values i.e. Z_{1:TT} (matrix) multiplied by
#'   parameters/coefficients (vector) i.e. a matrix (double)
#' @return deterministic state transition (one-period ahead conditional mean)
#'   as a \code{TTx1}-vector
#' @export
f_cpp_vech <- function(x_tt, phi_x, regs_add) {
    .Call(`_BNMPD_f_cpp_vech`, x_tt, phi_x, regs_add)
}

compute_err_sig_sq <- function(Z_part1, Z_part2, state_part, bet_part, phi_part, TT) {
    .Call(`_BNMPD_compute_err_sig_sq`, Z_part1, Z_part2, state_part, bet_part, phi_part, TT)
}

#' A cpp-wrapper for the R-internal MASS::mvrnorm()-function.
#'
#' The wrapper should produce the exact same multivariate normal random numbers
#' within rcpp/arma code.
#'
#' Similar to MASS::mvrnorm() the dimension of the result is taken from
#' \code{mu}/\code{Sigma} (the other arguments of MASS::mvrnorm are taken as
#' defaults).
#'
#' @param mu mean vector of the distribution (arma::vec)
#' @param Sigma variance covariance matrix of the distribution (arma::mat)
#' @return one draw from the multivariate normal with dimension taken from
#'   mu/Sigma
#' @export
mvrnorm_c <- function(mu, Sigma) {
    .Call(`_BNMPD_mvrnorm_c`, mu, Sigma)
}

#' helper function to check whether phi-parameter is out of bounds
#'
#' helper function to check whether phi-parameter is out of bounds
#'
#' @param phi autoregressive parameter of the state process (double) which is
#'   tested to be smaller than one in absolute value
#' @param eps precision (double); how close phi is allowed to be to +1 or -1
#' @return logical; if \code{TRUE}, then \code{phi} is smaller than one in
#'   absolute value given the precision \code{eps}
#' @export
test_phi_oob <- function(phi, eps) {
    .Call(`_BNMPD_test_phi_oob`, phi, eps)
}

#' State transition
#'
#' Helper function computing the deterministic state transition, or, to put
#' differently, the one-period ahead conditional mean of the latent state
#' process.
#'
#' This function is used internally in the SMC procedure when propagating
#' particles through time: it is applied per state component \code{d=1,...,DD}
#' on a \code{Nx1}-dimensional state vector where \code{N} is the number of
#' particles for a particular x_{t} at component \code{d}. This is the reason
#' for \code{regs_add} to be a scalar as it is the added regressor*beta change
#' for some \code{t=1,...,T}.
#'
#' @param x_tt particle value in t-1 i.e. x_{t-1}; \code{Nx1}-dimensional
#'   vector (double)
#' @param phi_x autoregressive parameter (double)
#' @param regs_add result of regressor values i.e. z_{t} (vector) multiplied by
#'   parameters/coefficients (vector) i.e. a scalar product (double)
#' @return deterministic state transition (one-period ahead conditional mean)
#'   as a \code{Nx1}-vector
#' @export
f_cpp <- function(x_tt, phi_x, regs_add) {
    .Call(`_BNMPD_f_cpp`, x_tt, phi_x, regs_add)
}

#' Computes the ancestor sampling weights.
#'
#' Computes the ancestor sampling weights.
#'
#' @param mean_diff difference matrix of mean values required (see the formal
#'   derivations of the ancesor weights in the project summary) (arma::mat)
#' @param vcm_diag the variance-covariance matrix of the \code{DD}-dimensional
#'   (conditional) state process i.e. the error term variances stacked along
#'   d=1,...,DD (arma::rowvec)
#' @param log_weights logarithmic particle weights \code{Nx1}-dimensional
#'   vector (arma::vec); see the derivations of the ancestor weights in the
#'   project summary for details
#' @param N number of particles (integer)
#' @param id_as_lnspc a arma::uvec starting from 1:N; redundant if R::sample()
#'   is used but necessary for the Armadillo functionality
#' @return ancestor index
#' @export
#'
w_as_c <- function(mean_diff, vcm_diag, log_weights, N, id_as_lnspc) {
    .Call(`_BNMPD_w_as_c`, mean_diff, vcm_diag, log_weights, N, id_as_lnspc)
}

#' SMC log-weights for the Dirichlet
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-model only.
#'
#' @param N number of particles (int)
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @return particle log-weights
#'
w_log_cbpf_d_old <- function(N, y, xa, id_x_all) {
    .Call(`_BNMPD_w_log_cbpf_d_old`, N, y, xa, id_x_all)
}

#' SMC log-weights for the Dirichlet
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-model only.
#'
#' @param N number of particles (int)
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @return particle log-weights
#'
w_log_cbpf_d <- function(N, y, xa, id_x_all) {
    .Call(`_BNMPD_w_log_cbpf_d`, N, y, xa, id_x_all)
}

#' SMC log-weights for the generalized Dirichlet
#'
#' Computes normalized Bootstrap-particle weights for the generalized
#' Dirichlet model.
#'
#' @param N number of particles (int)
#' @param DD2 number of state components (number of components in the
#'     multivariate latent state component) (int)
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD2}-dimensional arma::vec (as the
#'   whole state vector has \code{DD2} components and \code{N} is the number of
#'   particles)
#' @param id_x index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD2 within the \code{NxDD2} dimensional
#'   \code{xa}
#' @return particle log-weights
#'
w_log_cbpf_gd <- function(N, DD2, y, xa, id_x) {
    .Call(`_BNMPD_w_log_cbpf_gd`, N, DD2, y, xa, id_x)
}

#' SMC log-weights for the Dirichlet Multinomial
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-multinommial model only.
#'
#' @param N number of particles (int)
#' @param DD number of state components (dirichlet fractions or number of
#'   components in the multivariate latent state component) (int)
#' @param num_counts number of overall counts per t=1,...,TT (part of the
#'   measurement data) i.e. a scalar int-value for the current time period
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @param id_x index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD within the \code{NxDD} dimensional
#'   \code{xa}
#' @return particle log-weights
#'
w_log_cbpf_dm_old <- function(N, DD, num_counts, y, xa, id_x) {
    .Call(`_BNMPD_w_log_cbpf_dm_old`, N, DD, num_counts, y, xa, id_x)
}

#' SMC log-weights for the Dirichlet Multinomial
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-multinommial model only.
#'
#' @param N number of particles (int)
#' @param num_counts number of overall counts per t=1,...,TT (part of the
#'   measurement data) i.e. a scalar int-value for the current time period
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @param id_x_all index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD within the \code{NxDD} dimensional
#'   \code{xa}
#' @return particle log-weights
#'
w_log_cbpf_dm <- function(N, num_counts, y, xa, id_x_all) {
    .Call(`_BNMPD_w_log_cbpf_dm`, N, num_counts, y, xa, id_x_all)
}

#' SMC log-weights for the Multinomial
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-multinommial model only.
#'
#' @param N number of particles (int)
#' @param DD number of state components (dirichlet fractions or number of
#'   components in the multivariate latent state component) (int)
#' @param y counts of dimension \code{DD} (part of the measurement data)
#'   observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @param id_x index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD within the \code{NxDD} dimensional
#'   \code{xa}
#' @return particle log-weights
#'
w_log_cbpf_m <- function(N, DD, y, xa, id_x) {
    .Call(`_BNMPD_w_log_cbpf_m`, N, DD, y, xa, id_x)
}

#' Normalization of log-weights
#'
#' Both, SMC weights and ancestor sampling weights possible. The function does
#' the 'max-exp'-trick to make computations stable and avoid under- or
#' overflows.
#'
#' @param w \code{arma::vec} vector of log-weights which will be normalized
#' @param w_type a character string giving the weight type that's checked e.g.
#'   can be "particle" or "ancestor" meaning particle or ancestor weights;
#'   will be passed further to [check_weights()] as second argument
#'
#' @return an \code{arma::vec} vector of the same dimension as the input
#'   \code{w} that contains the normalized weights
#'
w_normalize_cpp <- function(w, w_type) {
    .Call(`_BNMPD_w_normalize_cpp`, w, w_type)
}

#' Checks for numeric anomalies in the weight computations.
#'
#' An error is thrown if any of the weights passed to the argument
#' \code{weight} are 'NA' or 'NaN'.
#'
#' @param w_log a numeric vector of weights to check
#' @param w_type a character string giving the weight type that's checked e.g.
#'   can be "particle" or "ancestor" meaning particle or ancestor weights; if
#'   called from top level function the prefix "normalized" is appended to
#'   indicate that 'normalized' (summing to unity) particle weights are checked
#'
#' @return void return; throws error or prints warning and modifies in place
#'   the problematic weights
#'
check_weights <- function(w_log, w_type) {
    invisible(.Call(`_BNMPD_check_weights`, w_log, w_type))
}

#' Throws error, warning, message etc.
#'
#' Throws error, warning, message etc.
#'
#' @param w_type a std::string giving the weight type to paste into final
#'   message
#' @param m_info a std::string to be transformed to a string.
#' @param m_type a std::string giving the type of the message return; either
#'   "warning" or "error"
#'
#' @return void return; prints message i.e. side effect function
#'
throw_weight_msg <- function(w_type, m_info, m_type) {
    invisible(.Call(`_BNMPD_throw_weight_msg`, w_type, m_info, m_type))
}

#' Throws error, warning, message etc.
#'
#' Throws error, warning, message etc.
#'
#' @param DD_all; integer giving (full) multivariate dimension
#' @param N integer giving the number of particles
#'
#' @return a sequence of integers (0, ..., DD_all * N - 1)
#'
compute_id_x_all <- function(DD_all, N) {
    .Call(`_BNMPD_compute_id_x_all`, DD_all, N)
}

#' Resampling function
#'
#' Either uses arma random numbers or R's random numbers (via Rcpp::sample) to
#' do a resampling step i.e. permuting the ancestor indices. Comment in/out the
#' corresponding parts required.
#'
#' @param weights arma::colvec of dimension \code{N} storing particle weights
#' @param N number of particles (int)
#' @param id_as_lnspc a arma::uvec starting from 1:N; redundant if R::sample()
#'   is used but necessary for the Armadillo functionality
#'
#' @return a arma::uvec of dimension \code{N} containing the resampled indices
resample <- function(weights, N, id_as_lnspc) {
    .Call(`_BNMPD_resample`, weights, N, id_as_lnspc)
}

#' Samples final particle trajectory index
#'
#' Last step of conditional SMC/BPF algorithm generates a particle trajectory
#' to output s.th. PGAS procedure can condition on this draw.
#'
#' @param weights arma::colvec of dimension \code{N} storing particle weights
#' @param N number of particles (int)
#'
#' @return returns sampled index (as double; check if int-type could be used)
#'
sample_final_trajectory <- function(weights, N) {
    .Call(`_BNMPD_sample_final_trajectory`, weights, N)
}

#' Samples initial particles from prior
#'
#' @param mmu mean value as double
#' @param sdd standard deviation as double
#' @param N number of particles (int)
#'
#' @return a draw from a multivariate normal with equal means (\code{mmu}) and
#'   standard deviations \code{sdd} as a \code{N}x1 arma::colvec
#'
sample_init_prtcls <- function(mmu, sdd, N) {
    .Call(`_BNMPD_sample_init_prtcls`, mmu, sdd, N)
}

#' Propagates particles forward
#'
#' As the bootstrap particle propagates particles forward via the state
#' transition equation we use the multivariate normal with appropriate mean
#' vector and standard deviation(in all our models we have a Gaussian state
#' transition).
#'
#' @param mmu mean vector of type arma::colvec
#' @param sdd standard deviation as double
#' @param N number of particles (int)
#'
#' @return a vector of forward sampled (i.e. propagated) particles of dimension
#'   \code{N}x1 (\code{arma::colvec})
#'
propagate_bpf <- function(mmu, sdd, N) {
    .Call(`_BNMPD_propagate_bpf`, mmu, sdd, N)
}

#' Runs a parallel version of the conditional SMC (BPF) for the Dirichlet model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' random numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param id_parallelize parallelization ID as an \code{IntegerVector}:
#'   determines along which cross sectional components to run the cSMC
#'   samplers: this is passed from the \code{x}-argument of
#'   \code{paralllel::clusterApply()}, called within the PGAS code, to this
#'   function so it knows along which cross sectional units it has to slice the
#'   data \code{y_all, regs_beta_all, x_r_all}
#' @param nn_list_dd a list of length \code{NN} with indices of multivariate
#'    components (a subset of \code{d=1,...,DD}) used for state filtering
#' @param N number of particles
#' @param TT time series dimension
#' @param DD multivariate dimension (number of dirichlet categories)
#' @param y_all measurements - Dirichlet fractions; dimension `TT x DD x NN`
#' @param regs_beta_all result of regressor matrix i.e. z_{t} multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r_all reference/conditioning trajectory; smae dimension as `y_all`
#'    i.e. `TT x DD x NN`
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
#'
cbpf_as_d_cpp_par <- function(id_parallelize, nn_list_dd, N, TT, DD, y_all, regs_beta_all, sig_sq_x, phi_x, x_r_all) {
    .Call(`_BNMPD_cbpf_as_d_cpp_par`, id_parallelize, nn_list_dd, N, TT, DD, y_all, regs_beta_all, sig_sq_x, phi_x, x_r_all)
}

#' Runs a parallel version of the conditional SMC/BPF for the Dir. Mult. model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' randon numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param id_parallelize parallelization ID as an \code{IntegerVector}:
#'   determines along which cross sectional components to run the cSMC
#'   samplers: this is passed from the \code{x}-argument of
#'   \code{paralllel::clusterApply()}, called within the PGAS code, to this
#'   function so it knows along which cross sectional unit it has to slice the
#'   data \code{y_all, num_counts_all, regs_beta_all, x_r_all}
#' @param nn_list_dd a list of length \code{NN} with indices of multivariate
#'    components (a subset of \code{d=1,...,DD}) used for state filtering
#' @param N number of particles
#' @param TT time series dimension
#' @param DD multivariate dimension (number of dirichlet-mult. categories)
#' @param y_all measurements: dirichlet-multinomial counts
#' @param num_counts_all measurements: dirichlet-multinomial total counts per
#'   time period (\code{T}-dimensional vector)
#' @param regs_beta_all result of regressor matrix i.e. z_{t} multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r_all reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
#'
cbpf_as_dm_cpp_par <- function(id_parallelize, nn_list_dd, N, TT, DD, y_all, num_counts_all, regs_beta_all, sig_sq_x, phi_x, x_r_all) {
    .Call(`_BNMPD_cbpf_as_dm_cpp_par`, id_parallelize, nn_list_dd, N, TT, DD, y_all, num_counts_all, regs_beta_all, sig_sq_x, phi_x, x_r_all)
}

#' Runs a parallel version of the conditional SMC (BPF) for the Dirichlet model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' random numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param id_parallelize parallelization ID as an \code{IntegerVector}:
#'   determines along which cross sectional components to run the cSMC
#'   samplers: this is passed from the \code{x}-argument of
#'   \code{paralllel::clusterApply()}, called within the PGAS code, to this
#'   function so it knows along which cross sectional units it has to slice the
#'   data \code{y_all, regs_beta_all, x_r_all}
#' @param nn_list_dd a list of length \code{NN} with indices of multivariate
#'    components (a subset of \code{d=1,...,DD}) used for state filtering
#' @param N number of particles
#' @param TT time series dimension
#' @param DD multivariate dimension (number of dirichlet categories)
#' @param y_all measurements: dirichlet fractions
#' @param regs_beta_all result of regressor matrix i.e. z_{t} multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r_all reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
#'
cbpf_as_gd_cpp_par <- function(id_parallelize, nn_list_dd, N, TT, DD, DD2, y_all, regs_beta_all, sig_sq_x, phi_x, x_r_all) {
    .Call(`_BNMPD_cbpf_as_gd_cpp_par`, id_parallelize, nn_list_dd, N, TT, DD, DD2, y_all, regs_beta_all, sig_sq_x, phi_x, x_r_all)
}

#' Runs a parallel version of the conditional SMC/BPF for the Dir. Mult. model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' randon numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param id_parallelize parallelization ID as an \code{IntegerVector}:
#'   determines along which cross sectional components to run the cSMC
#'   samplers: this is passed from the \code{x}-argument of
#'   \code{paralllel::clusterApply()}, called within the PGAS code, to this
#'   function so it knows along which cross sectional unit it has to slice the
#'   data \code{y_all, num_counts_all, regs_beta_all, x_r_all}
#' @param nn_list_dd a list of length \code{NN} with indices of multivariate
#'    components (a subset of \code{d=1,...,DD}) used for state filtering
#' @param N number of particles
#' @param TT time series dimension
#' @param DD multivariate dimension (number of dirichlet-mult. categories)
#' @param y_all measurements: dirichlet-multinomial counts
#' @param num_counts_all measurements: dirichlet-multinomial total counts per
#'   time period (\code{T}-dimensional vector)
#' @param regs_beta_all result of regressor matrix i.e. z_{t} multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r_all reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
#'
cbpf_as_gdm_cpp_par <- function(id_parallelize, nn_list_dd, N, TT, DD, y_all, num_counts_all, regs_beta_all, sig_sq_x, phi_x, x_r_all) {
    .Call(`_BNMPD_cbpf_as_gdm_cpp_par`, id_parallelize, nn_list_dd, N, TT, DD, y_all, num_counts_all, regs_beta_all, sig_sq_x, phi_x, x_r_all)
}

#' Runs a parallel version of the conditional SMC (BPF) for the Mult. model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' randon numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param id_par_vec parallelization ID as an \code{IntegerVector}: determines
#'   along which cross sectional component to compute: this is passed from the
#'   \code{x}-argument of \code{paralllel::clusterApply()}, called within the
#'   PGAS code, to this function so it knows along for which cross sectional
#'   unit it has to slice the data: \code{y_all, num_counts_all, Regs_beta_all,
#'   x_r_all}; see arguments below
#' @param N number of particles
#' @param TT time series dimension
#' @param DD multivariate dimension (number of multinomial categories)
#' @param y_all measurements: multinomial counts
#' @param Regs_beta_all  result of regressor values i.e. z_{t} (matrix)
#'   multiplied by parameters/coefficients (vector) over ALL \code{d=1...DD}
#'   components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r_all reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
#'
cbpf_as_m_cpp_par <- function(id_par_vec, N, TT, DD, y_all, Regs_beta_all, sig_sq_x, phi_x, x_r_all) {
    .Call(`_BNMPD_cbpf_as_m_cpp_par`, id_par_vec, N, TT, DD, y_all, Regs_beta_all, sig_sq_x, phi_x, x_r_all)
}

#' Computes bet_z MCMC parts
#'
#' @param dd bla
#' @param DD bla
#' @param N bla
#' @param T bla
#' @param dim_bet_z_d bla
#' @param vcm_x_errors_lhs bla
#' @param vcm_x_errors_rhs bla
#' @param prior_vcm_bet_z bla
#' @param X bla
#' @param regsz bla
#' @param id_regz bla
#' @return some value
#'
#' @export
bet_z_components <- function(dd, DD, N, T, dim_bet_z_d, vcm_x_errors_lhs, vcm_x_errors_rhs, prior_vcm_bet_z, X, regsz, id_regz) {
    .Call(`_BNMPD_bet_z_components`, dd, DD, N, T, dim_bet_z_d, vcm_x_errors_lhs, vcm_x_errors_rhs, prior_vcm_bet_z, X, regsz, id_regz)
}

