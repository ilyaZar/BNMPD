# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' helper function to check whether phi-parameter is out of bounds
#'
#' helper function to check whether phi-parameter is out of bounds
#'
#' @param phi autoregressive parameter of the state process (double) which is
#'   tested to be smaller than one in absolute value
#' @param eps precision (double); how close phi is allowed to be to +1 or -1
#' @return logical; if \code{TRUE}, then \code{phi} is smaller than one in
#'   absolute value given the precision \code{eps}
#' @export
test_phi_oob <- function(phi, eps) {
    .Call(`_BNMPD_test_phi_oob`, phi, eps)
}

#' State transition
#'
#' Helper function computing the deterministic state transition, or, to put
#' differently, the one-period ahead conditional mean of the latent state
#' process. This version is required for the MCMC part, not the SMC part.
#'
#' This function is used internally in the PGAS procedure for MCMC sampling of
#' parameters when subtracting the mean from the state process: it is applied
#' per state component \code{d=1,...,DD} on a \code{TTx1}-dimensional state
#' vector where \code{TT} is the number of time periods of all the \code{DD}
#' components. This is the reason for \code{regs_add} to be a vector as it adds
#' regressor*beta (i.e. regressors matrix time coefficient vector) change for
#' all \code{t=1,...,T}.
#'
#' @param x_tt particle value in t-1 i.e. x_{t-1}; \code{TTx1}-dimensional
#'   vector (double)
#' @param phi_x autoregressive parameter (double)
#' @param regs_add result of regressor values i.e. Z_{1:TT} (matrix) multiplied by
#'   parameters/coefficients (vector) i.e. a matrix (double)
#' @return deterministic state transition (one-period ahead conditional mean)
#'   as a \code{TTx1}-vector
#' @export
f_cpp_vech <- function(x_tt, phi_x, regs_add) {
    .Call(`_BNMPD_f_cpp_vech`, x_tt, phi_x, regs_add)
}

compute_err_sig_sq <- function(Z_part1, Z_part2, state_part, bet_part, phi_part, TT) {
    .Call(`_BNMPD_compute_err_sig_sq`, Z_part1, Z_part2, state_part, bet_part, phi_part, TT)
}

#' A cpp-wrapper for the R-internal MASS::mvrnorm()-function.
#'
#' The wrapper should produce the exact same multivariate normal random numbers
#' within rcpp/arma code.
#'
#' Similar to MASS::mvrnorm() the dimension of the result is taken from
#' \code{mu}/\code{Sigma} (the other arguments of MASS::mvrnorm are taken as
#' defaults).
#'
#' @param mu mean vector of the distribution (arma::vec)
#' @param Sigma variance covariance matrix of the distribution (arma::mat)
#' @return one draw from the multivariate normal with dimension taken from
#'   mu/Sigma
#' @export
mvrnorm_c <- function(mu, Sigma) {
    .Call(`_BNMPD_mvrnorm_c`, mu, Sigma)
}

#' State transition
#'
#' Helper function computing the deterministic state transition, or, to put
#' differently, the one-period ahead conditional mean of the latent state
#' process.
#'
#' This function is used internally in the SMC procedure when propagating
#' particles through time: it is applied per state component \code{d=1,...,DD}
#' on a \code{Nx1}-dimensional state vector where \code{N} is the number of
#' particles for a particular x_{t} at component \code{d}. This is the reason
#' for \code{regs_add} to be a scalar as it is the added regressor*beta change for
#' some \code{t=1,...,T}.
#'
#' @param x_tt particle value in t-1 i.e. x_{t-1}; \code{Nx1}-dimensional
#'   vector (double)
#' @param phi_x autoregressive parameter (double)
#' @param regs_add result of regressor values i.e. z_{t} (vector) multiplied by
#'   parameters/coefficients (vector) i.e. a scalar product (double)
#' @return deterministic state transition (one-period ahead conditional mean)
#'   as a \code{Nx1}-vector
#' @export
f_cpp <- function(x_tt, phi_x, regs_add) {
    .Call(`_BNMPD_f_cpp`, x_tt, phi_x, regs_add)
}

#' Computes the ancestor sampling weights.
#'
#' Computes the ancestor sampling weights.
#'
#' @param mean_diff difference matrix of mean values required (see the formal
#'   derivations of the ancesor weights in the project summary) (arma::mat)
#' @param vcm_diag the variance-covariance matrix of the \code{DD}-dimensional
#'   (conditional) state process i.e. the error term variances stacked along
#'   d=1,...,DD (arma::rowvec)
#' @param log_weights logarithmic particle weights \code{Nx1}-dimensional
#'   vector (arma::vec); see the derivations of the ancestor weights in the
#'   project summary for details
#' @param N number of particles (integer)
#' @param id_as_lnspc a arma::uvec starting from 1:N; redundant if R::sample()
#'   is used but necessary for the Armadillo functionality
#' @return ancestor weights of dimension \code{Nx1}-dimensional (for each
#'   particle)
#' @export
w_as_c <- function(mean_diff, vcm_diag, log_weights, N, id_as_lnspc) {
    .Call(`_BNMPD_w_as_c`, mean_diff, vcm_diag, log_weights, N, id_as_lnspc)
}

#' SMC log-weights for the Dirichlet
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-model only.
#'
#' @param N number of particles (int)
#' @param DD number of state components (dirichlet fractions or number of
#'   components in the multivariate latent state component) (int)
#' @param num_counts number of overall counts per t=1,...,TT (part of the
#'   measurement data) i.e. a scalar int-value for the current time period
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @param id_x index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD within the \code{NxDD} dimensional
#'   \code{xa}
#' @return particle weights
#'
w_log_cbpf_d <- function(N, DD, num_counts, y, xa, id_x) {
    .Call(`_BNMPD_w_log_cbpf_d`, N, DD, num_counts, y, xa, id_x)
}

#' SMC log-weights for the Dirichlet Multinomial
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-multinommial model only.
#'
#' @param N number of particles (int)
#' @param DD number of state components (dirichlet fractions or number of
#'   components in the multivariate latent state component) (int)
#' @param num_counts number of overall counts per t=1,...,TT (part of the
#'   measurement data) i.e. a scalar int-value for the current time period
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @param id_x index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD within the \code{NxDD} dimensional
#'   \code{xa}
#' @return particle weights
#'
w_log_cbpf_dm <- function(N, DD, num_counts, y, xa, id_x) {
    .Call(`_BNMPD_w_log_cbpf_dm`, N, DD, num_counts, y, xa, id_x)
}

#' SMC log-weights for the Dirichlet Multinomial; the BH-version
#'
#' Computes normalized bootrstrap particle weights; same as
#' \code{w_log_d_cbpf()} but uses higher precision containers to deal with
#' over- and underflow issues.
#'
#' Can currently be used for Dirichlet-multinommial model only.
#'
#' @param N number of particles (int)
#' @param DD number of state components (dirichlet fractions or number of
#'   components in the multivariate latent state component) (int)
#' @param num_counts number of overall counts per t=1,...,TT (part of the
#'   measurement data) i.e. a scalar int-value for the current time period
#' @param y Dirichlet fractions/shares of dimension \code{DD} (part of the
#'   measurement data) observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @param id_x index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD within the \code{NxDD} dimensional
#'   \code{xa}
#' @return particle weights
#'
w_log_cbpf_dm_bh <- function(N, DD, num_counts, y, xa, id_x) {
    .Call(`_BNMPD_w_log_cbpf_dm_bh`, N, DD, num_counts, y, xa, id_x)
}

#' SMC log-weights for the Multinomial
#'
#' Computes normalized bootrstrap particle weights.
#'
#' Can currently be used for Dirichlet-multinommial model only.
#'
#' @param N number of particles (int)
#' @param DD number of state components (dirichlet fractions or number of
#'   components in the multivariate latent state component) (int)
#' @param y counts of dimension \code{DD} (part of the measurement data)
#'   observed a specific t=1,...,TT; (arma::rowvec)
#' @param xa particle state vector; \code{NxDD}-dimensional arma::vec (as the
#'   whole state vector has \code{DD} components and \code{N} is the number of
#'   particles)
#' @param id_x index vector giving the location of the N-dimensional components
#'   for each subcomponent d=1,...,DD within the \code{NxDD} dimensional
#'   \code{xa}
#' @return particle weights
#'
w_log_cbpf_m <- function(N, DD, y, xa, id_x) {
    .Call(`_BNMPD_w_log_cbpf_m`, N, DD, y, xa, id_x)
}

#' Normalization of log-weights
#'
#' Both, SMC weights and ancestor sampling weights possible. The function does
#' the 'max-exp'-trick to make computations stable and avoid under- or
#' overflows.
#'
#' @param w \code{arma::vec} vector of log-weights which will be normalized
#' @return an \code{arma::vec} vector of the same dimension as the input \code{w} that
#'   contains the normalized weights
#'
w_normalize_cpp <- function(w) {
    .Call(`_BNMPD_w_normalize_cpp`, w)
}

#' Resampling function
#'
#' Either uses arma random numbers or R's random numbers (via Rcpp::sample) to
#' do a resampling step i.e. permuting the ancestor indices. Comment in/out the
#' corresponding parts required.
#'
#' @param weights arma::colvec of dimension \code{N} storing particle weights
#' @param N number of particles (int)
#' @param id_as_lnspc a arma::uvec starting from 1:N; redundant if R::sample()
#'   is used but necessary for the Armadillo functionality
#'
#' @return a arma::uvec of dimension \code{N} containing the resampled indices
resample <- function(weights, N, id_as_lnspc) {
    .Call(`_BNMPD_resample`, weights, N, id_as_lnspc)
}

#' Samples final particle trajectory index
#'
#' Last step of conditional SMC/BPF algorithm generates a particle trajectory
#' to output s.th. PGAS procedure can condition on this draw.
#'
#' @param weights arma::colvec of dimension \code{N} storing particle weights
#' @param N number of particles (int)
#' @param id_as_lnspc a arma::uvec starting from 1:N; redundant if R::sample()
#'   is used but necessary for the Armadillo functionality
#'
#' @return returns sampled index (as double; check if int-type could be used)
#'
sample_final_trajectory <- function(weights, N, id_as_lnspc) {
    .Call(`_BNMPD_sample_final_trajectory`, weights, N, id_as_lnspc)
}

#' Samples initial particles from prior
#'
#' @param mmu mean value as double
#' @param sdd standard deviation as double
#' @param N number of particles (int)
#'
#' @return a draw from a multivariate normal with equal means (\code{mmu}) and
#'   standard deviations \code{sdd} as a \code{N}x1 arma::colvec
#'
sample_init_prtcls <- function(mmu, sdd, N) {
    .Call(`_BNMPD_sample_init_prtcls`, mmu, sdd, N)
}

#' Propagates particles forward
#'
#' As the bootstrap particle propagates particles forward via the state
#' transition equation we use the multivariate normal with appropriate mean
#' vector and standard deviation(in all our models we have a Gaussian state
#' transition).
#'
#' @param mmu mean vector of type arma::colvec
#' @param sdd standard deviation as double
#' @param N number of particles (int)
#'
#' @return a vector of forward sampled (i.e. propagated) particles of dimension
#'   \code{N}x1 (\code{arma::colvec})
#'
propagate_bpf <- function(mmu, sdd, N) {
    .Call(`_BNMPD_propagate_bpf`, mmu, sdd, N)
}

#' Runs a conditional SMC (bootstrap particle filter) for the Dir. Mult. model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' randon numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param N number of particles
#' @param TT time series dimension
#' @param DD number of dirichlet fractions/shares i.e. categories
#' @param y measurements: dirichlet fractions/shares
#' @param num_counts measurements: dirichlet-multinomial total counts per time
#'   period (\code{T}-dimensional vector)
#' @param Regs_beta  result of regressor values i.e. z_{t} (matrix) multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
cbpf_as_dm_cpp <- function(N, TT, DD, y, num_counts, Regs_beta, sig_sq_x, phi_x, x_r) {
    .Call(`_BNMPD_cbpf_as_dm_cpp`, N, TT, DD, y, num_counts, Regs_beta, sig_sq_x, phi_x, x_r)
}

#' Runs a conditional SMC (bootstrap particle filter) for the Multinomial model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' randon numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param N number of particles
#' @param TT time series dimension
#' @param DD number of dirichlet fractions/shares i.e. categories
#' @param y measurements: dirichlet fractions/shares
#' @param Regs_beta  result of regressor values i.e. z_{t} (matrix) multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
cbpf_as_m_cpp <- function(N, TT, DD, y, Regs_beta, sig_sq_x, phi_x, x_r) {
    .Call(`_BNMPD_cbpf_as_m_cpp`, N, TT, DD, y, Regs_beta, sig_sq_x, phi_x, x_r)
}

#' Runs a parallel version of the conditional SMC (BPF) for the Dir. Mult. model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' randon numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param id_par_vec parallelization ID as an \code{IntegerVector}: determines
#'   along which cross sectional component to compute: this is passed from the
#'   \code{x}-argument of \code{paralllel::clusterApply()}, called within the
#'   PGAS code, to this function so it knows along for which cross sectional
#'   unit it has to slice the data: \code{y_all, num_counts_all, Regs_beta_all,
#'   x_r_all}; see arguments below
#' @param N number of particles
#' @param TT time series dimension
#' @param DD multivariate dimension (number of dirichlet-multinomial categories)
#' @param y_all measurements: dirichlet-multinomial counts
#' @param num_counts_all measurements: dirichlet-multinomial total counts per time
#'   period (\code{T}-dimensional vector)
#' @param Regs_beta_all  result of regressor values i.e. z_{t} (matrix) multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r_all reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
#'
cbpf_as_dm_cpp_par <- function(id_par_vec, N, TT, DD, y_all, num_counts_all, Regs_beta_all, sig_sq_x, phi_x, x_r_all) {
    .Call(`_BNMPD_cbpf_as_dm_cpp_par`, id_par_vec, N, TT, DD, y_all, num_counts_all, Regs_beta_all, sig_sq_x, phi_x, x_r_all)
}

#' Runs a parallel version of the conditional SMC (BPF) for the Mult. model
#'
#' Runs a conditional bootstrap particle filter with ancestor sampling and arma
#' randon numbers (see the use of arma::randn()). Used within a PGAS procedure
#' e.g. called via \code{pgas_arma()}.
#'
#' @param id_par_vec parallelization ID as an \code{IntegerVector}: determines
#'   along which cross sectional component to compute: this is passed from the
#'   \code{x}-argument of \code{paralllel::clusterApply()}, called within the
#'   PGAS code, to this function so it knows along for which cross sectional
#'   unit it has to slice the data: \code{y_all, num_counts_all, Regs_beta_all,
#'   x_r_all}; see arguments below
#' @param N number of particles
#' @param TT time series dimension
#' @param DD multivariate dimension (number of multinomial categories)
#' @param y_all measurements: multinomial counts
#' @param Regs_beta_all  result of regressor values i.e. z_{t} (matrix) multiplied by
#'   parameters/coefficients (vector) over ALL \code{d=1...DD} components
#' @param sig_sq_x \code{DD}-dimensional vector of latent state error variance
#' @param phi_x \code{DD}-dimensional vector of autoregressive parameters of
#'   latent state process
#' @param x_r_all reference/conditioning trajectory
#'
#' @return arma::matrix of DD components: DD columns are
#'   \code{NxTT}-dimensional matrices each containing the conditional BPF
#'   output per d'th component
#' @export
#'
cbpf_as_m_cpp_par <- function(id_par_vec, N, TT, DD, y_all, Regs_beta_all, sig_sq_x, phi_x, x_r_all) {
    .Call(`_BNMPD_cbpf_as_m_cpp_par`, id_par_vec, N, TT, DD, y_all, Regs_beta_all, sig_sq_x, phi_x, x_r_all)
}

#' Particle Gibbs with ancestor sampling (PGAS)
#'
#' Runs PGAS with various possible SMC procedures and Gibbs blocks. In this
#' case we use Armadillo random numbers for the MCMC part and the arma version
#' of the conditional SMC (in principle, all combinations are possible e.g.
#' using Rcpp/base-R random numbers for MCMC while the SMC procedure may rely
#' on arma random numbers)
#'
#' @param N number of particles
#' @param NN cross sectional dimension
#' @param TT time series dimension
#' @param DD multivariate dimension (number of dirichlet-multinomial categories)
#' @param MM PGAS iterations i.e. MCMC iterations (which is equal to the number
#'   of iterations of the SMC-part)
#' @param data a list of data objects i.e. measurements: e.g. can be total counts
#'   as well as dirichlet multinomial number of counts per category (only the latter
#'   if measurements are from a multinomial, and both if measurements come from a
#'   multinomial-dirichlet)
#' @param Z regressors contained in the latent state process part
#' @param priors hyperpriors for inverted gamma priors of the state process
#'   error variances
#' @param par_init initial parameters i.e. starting values for the MCMC part of
#'   the overall PGAS procedure
#' @param traj_init initial latent state values i.e. starting values for the
#'   SMC part of the overall PGAS procedure
#' @return List of parameter MCMC samples and latent state trajectory outputs
#'
#' @export
pgas_cpp_dm <- function(N, NN, TT, DD, MM, data, Z, priors, par_init, traj_init) {
    .Call(`_BNMPD_pgas_cpp_dm`, N, NN, TT, DD, MM, data, Z, priors, par_init, traj_init)
}

#' Particle Gibbs with ancestor sampling (PGAS)
#'
#' Runs PGAS with various possible SMC procedures and Gibbs blocks. In this
#' case we use Armadillo random numbers for the MCMC part and the arma version
#' of the conditional SMC (in principle, all combinations are possible e.g.
#' using Rcpp/base-R random numbers for MCMC while the SMC procedure may rely
#' on arma random numbers)
#'
#' @param N number of particles
#' @param NN cross sectional dimension
#' @param TT time series dimension
#' @param DD multivariate dimension (number of multinomial categories)
#' @param MM PGAS iterations i.e. MCMC iterations (which is equal to the number
#'   of iterations of the SMC-part)
#' @param data a list of data objects i.e. measurements: e.g. can be total counts
#'   as well as dirichlet multinomial number of counts per category (only the latter
#'   if measurements are from a multinomial, and both if measurements come from a
#'   multinomial-dirichlet)
#' @param Z regressors contained in the latent state process part
#' @param priors hyperpriors for inverted gamma priors of the state process
#'   error variances
#' @param par_init initial parameters i.e. starting values for the MCMC part of
#'   the overall PGAS procedure
#' @param traj_init initial latent state values i.e. starting values for the
#'   SMC part of the overall PGAS procedure
#' @return List of parameter MCMC samples and latent state trajectory outputs
#'
#' @export
pgas_cpp_m <- function(N, NN, TT, DD, MM, data, Z, priors, par_init, traj_init) {
    .Call(`_BNMPD_pgas_cpp_m`, N, NN, TT, DD, MM, data, Z, priors, par_init, traj_init)
}

#' Computes bet_z MCMC parts
#'
#' @param dd bla
#' @param DD bla
#' @param N bla
#' @param T bla
#' @param dim_bet_z_d bla
#' @param vcm_x_errors_lhs bla
#' @param vcm_x_errors_rhs bla
#' @param prior_vcm_bet_z bla
#' @param X bla
#' @param regsz bla
#' @param id_regz bla
#' @return some value
#'
#' @export
bet_z_components <- function(dd, DD, N, T, dim_bet_z_d, vcm_x_errors_lhs, vcm_x_errors_rhs, prior_vcm_bet_z, X, regsz, id_regz) {
    .Call(`_BNMPD_bet_z_components`, dd, DD, N, T, dim_bet_z_d, vcm_x_errors_lhs, vcm_x_errors_rhs, prior_vcm_bet_z, X, regsz, id_regz)
}

